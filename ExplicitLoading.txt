--------------------------------ðŸš€ Understanding Explicit Loading in EF Core----------------------------------------------------------

We already learned about:

    Lazy Loading = Loads related data only when needed.
    Eager Loading = Loads everything at once.

Now, letâ€™s talk about Explicit Loading, which is like a mix of both! ðŸŽ­
ðŸ”Ž What is Explicit Loading?

Explicit Loading means you decide when to load related data manually.
ðŸª Example: A Customer Wants Specific Information

Imagine a customer comes to your toy store and says:
1ï¸âƒ£ "Give me a list of all toys." ðŸ§¸ (First Request)
2ï¸âƒ£ After a few minutes, they say: "Now tell me who bought the Teddy Bear." ðŸ§â€â™‚ï¸ (Second Request)

Instead of loading all the customer details in the first request (Eager Loading) or loading them automatically when accessed (Lazy Loading), you manually fetch the related data only when needed.
ðŸ“ Code Example of Explicit Loading

using (var context = new ToyStoreContext())  
{  
    var toy = context.Toys.FirstOrDefault(t => t.Name == "Teddy Bear"); // Load only the toy  

    // Later, when needed, manually load the orders
    context.Entry(toy).Collection(t => t.Orders).Load();  
}

ðŸ”µ What happens?

    The first query only loads the toy.
    The second query loads the related orders manually when we decide to fetch them.

ðŸ‘‰ EF Core Translates This to Two SQL Queries:

SELECT * FROM Toys WHERE Name = 'Teddy Bear';  -- First Query (Loads Only Toy)
SELECT * FROM Orders WHERE ToyId = 1;         -- Second Query (Loads Orders When Needed)

ðŸ“Š How is Explicit Loading Different?
Feature	Lazy Loading ðŸ’¤	Eager Loading ðŸš€	Explicit Loading ðŸŽ­
When Data is Loaded	Automatically when accessed	Immediately with main data	Manually, when we decide
Number of Queries	Multiple small queries	One big query	Two or more queries (controlled)
Best For	Small apps where related data is rarely used	Large apps where related data is always needed	When you need control over when to load data

ðŸ’¡ Use Explicit Loading when:

    You donâ€™t want to load unnecessary data upfront.
    You need more control over when related data is fetched.
    You want to reduce memory usage but still load related data efficiently.

ðŸŽ‰ How a 5-Year-Old Can Remember This

    Lazy Loading = Wait until you ask for it.
    Eager Loading = Get everything immediately.
    Explicit Loading = You decide when to fetch more details!


    ----------------------------------------REAL-WORLD SCENARIO --------------------------------------------------------------------------

    ðŸ“Œ 3ï¸âƒ£ Real-World Scenario for Explicit Loading ðŸŽ­
ðŸ¥ Healthcare System (Patient Records)

Imagine a hospital management system where doctors only see basic patient info by default but can request medical history when needed.

    A doctor's dashboard shows only Patient Name, Age, and Condition.
    If the doctor wants to see medical history, then the system loads that data only when requested.

How Explicit Loading Helps Here:

    It does not load unnecessary data upfront, saving memory.
    It allows manual control over when extra data is retrieved.

ðŸ”µ Example in EF Core:

var patient = context.Patients.FirstOrDefault(p => p.Id == 10);  // Load only patient details
context.Entry(patient).Collection(p => p.MedicalHistory).Load();  // Load medical history manually

ðŸ‘‰ EF Core loads the medical history only when needed, reducing initial load time.

âœ” Best for: Apps where related data is rarely needed but must be loaded on request

-------------------------------------------------------------------------------------------------------------------------------
ðŸŽ¯ Summary: Which One Should You Use?
Feature	    Lazy Loading ðŸ’¤	                          Eager Loading ðŸš€	                        Explicit Loading ðŸŽ­

Use Case	When related data is rarely needed	     When related data is always needed	       When manual control is required
Performance	Faster initial load, multiple queries	 Single query but more data loaded	       Controlled, but multiple queries
Best for	E-commerce, blogs, comments, logs	    HR systems, reports, dashboards	           Healthcare, finance, large datasets